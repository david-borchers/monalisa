\documentclass[10pt,a4paper]{article}
\usepackage{authblk}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{amsmath}
\usepackage{bm}
\usepackage[authoryear,round, longnamesfirst]{natbib}
\usepackage{textcomp}
\usepackage{setspace}
\doublespacing
\usepackage{fancyhdr}
\usepackage[]{todonotes}
\presetkeys{todonotes}{fancyline, color=white}{}

\pagestyle{fancy}
\rhead{That's not the Mona Lisa}
\lhead{}

\usepackage{lineno}
\linenumbers
%\linespread{1.6}

\renewcommand{\thesection}{Appendix \Alph{section}}
\renewcommand{\thesubsection}{\Alph{section}\arabic{subsection}}
\renewcommand{\thefigure}{\Alph{section}\arabic{figure}}  

\author[1,2,*]{Ian Durbach}
\author[3]{Rishika Chopara}
\author[1,2]{David L. Borchers}
\author[1]{Rachel Phillip}
\author[4]{Koustubh Sharma}
\author[3]{Ben C. Stevenson}

\affil[1]{\footnotesize Centre for Research into Ecological and Environmental Modelling, School of Mathematics and Statistics, Univeristy of St Andrews, The Observatory, St Andrews, Fife, KY16 9LZ, Scotland}
\affil[2]{\footnotesize Centre for Statistics in Ecology, the Environment and Conservation, Department of Statistical Sciences, University of Cape Town, South Africa}
\affil[3]{\footnotesize Department of Statistics, University of Auckland, Auckland 1010, New Zealand}
\affil[4]{\footnotesize Snow Leopard Trust, Seattle, Washington, United States of America}
\affil[*]{\footnotesize Corresponding author: indurbach@gmail.com}

\date{}

\title{Supplementary Material: That's not the Mona Lisa! How to interpret spatial capture-recapture density surface estimates}


\begin{document}

\maketitle

\section{Bayesian models}

Results presented in Section 4 in our manuscript were generated by
fitting maximum-likelihood SCR models to simulated data. In this
appendix we reproduce results from Section 4 using Bayesian models
fitted via MCMC to demonstrate that our conclusions are not simply a
consequence of adopting a classical approach. We focus on reproducing
Figures 5 and a single-simulation version of Figure 6 from the manuscript; other figures are based on averages over 100 simulations, which would require considerable
computation time given that fitting SCR models via MCMC is more time
consuming than maximum likelihood.

In Section \ref{sec:appendix-model-fitting} we describe our Bayesian
models, and in Section \ref{sec:appendix-results} we summarise our
results.

\subsection{Model fitting}
\label{sec:appendix-model-fitting}

We fitted Bayesian versions of the maximum-likelihood models presented
in Section 4 to each data set. Again, we used models with constant
density to estimate realised AC and realised usage surfaces, and a
model with inhomogeneous density characterised by a log-linear
relationship with a spatial covariate to estimate expected AC density
surfaces.

We fitted our models in NIMBLE \citep{deValpine:17, Turek:21} using
data augmentation \citep{Tanner:87}, which has become the prevailing
way to fit SCR models under a Bayesian framework. This approach
involves sampling a superpopulation of $M$ activity centres, including
those of the $n$ animals detected on the SCR survey. We have an
indicator variable $z_i$ for the $i$th animal, denoting whether the
$i$th animal in the augmented population `exists' in a given MCMC
iteration. Rather than directly estimating $N$, the population size,
we estimate the data augmentation parameter, $\psi$, the proportion of
the animals in the superpopulation for which the indicator is equal to
1. For each MCMC iteration we obtain a sample from the posterior of
$N$ using $\sum_{\i = 1}^M z_i$. A sample from the posterior for
animal density can be obtained by dividing each estimate of $N$ by the area of the survey
region. Further details on data augmentation can be found in
\citet[][pp.\ 139--157]{Kery+Schaub:12}.

We used the following uninformative priors for the detection function
parameters, specifying a prior for $\log\{1/(2\sigma^2)\}$ rather than
$\sigma$ directly:
\begin{align*}
  \lambda_0 &\sim \text{Gamma}(0.001, 0.001) \\
  \log\left(\frac{1}{2\sigma^2}\right) &\sim \text{Uniform}(-10, 10)
\end{align*}

For the constant density model, the activity centres were given a
uniform prior distribution over the survey region and the data
augmentation parameter was given a uniform prior from 0 to 1. For the
inhomogeneous density model, animal density at location $\bm{x}$ is
given by $D(\bm{x}) = \exp\{\beta_0 + \beta_1 y(\bm{x})\}$, where
$y(\bm{x})$ is a measurement of a covariate at location $\bm{x}$. We
used the following uninformative priors for the coefficients $\beta_0$
and $\beta_1$:
\begin{align*}
\beta_0 &\sim \text{Uniform}(-10, 10) \\
\beta_1 &\sim \text{Uniform}(-10, 10)
\end{align*}

When we fit each constant density model, we ran 11\,000 MCMC
iterations, where we set M to be equal to 300. We also used an
adaptation interval of 1000, and discarded 1000 iterations as burn-in.

When fitting each inhomogeneous density model, we ran 101\,000 MCMC
iterations, and used a value of 300 for M. We didn't use an
adaptation interval, and discarded 1000 iterations as burn-in.

\subsection{Results}
\label{sec:appendix-results}

We created trace plots for all parameters across all models, and none
of them indicated a lack of convergence. Although we do not present
them here for brevity, the point estimates (calculated using the
posterior mean) of all parameters were very similar to those obtained
via maximum likelihood models fitted to the same data.

The plots based on our Bayesian models fitted via MCMC (Figures
\ref{fig:fig7} and \ref{fig:fig9}, respectively) were qualitatively
similar to those based on maximum likelihood models (respectively, Figure 5 and a single-survey version of Figure 6 shown in\ref{fig:fig9-mle}). We observed that the
locations with the highest AC densities in Figure \ref{fig:fig9} were
shifted slightly further from the detectors, relative to Figure \ref{fig:fig9-mle}. A
potential explanation for subtle differences is that our Bayesian
plots are constructed based on entire posterior distributions, whereas
the maximum likelihood alternatives only use point estimates.

<<fig7, echo = FALSE, include = TRUE, fig.cap = "A version of Figure 4 from the manuscript based on our Bayesian models fitted via MCMC.", message=FALSE, fig.width=10, warning=FALSE, results=hide, fig=TRUE>>=
## Libraries we need
library(nimble)
library(coda)
library(nimbleSCR)
library(spatstat)
library(ggplot2)
library(dplyr)
library(stringr)
library(purrr)
library(secr)
library(patchwork)
library(ggpubr)
## Objects we need
load("../../output/revision/mona-inputs.RData")
load("../../output/revision/mona-results.RData")
## Functions we need
source("../../bayesian_code/Functions.R")

## ---------------------------------------------------------------------------------------
######################## Creating the objects needed for Figure 4 ########################
## ---------------------------------------------------------------------------------------

## In this figure, the first column uses simulated data w/ 18 sampling occasions. The second column uses simulated data w/ 52 sampling occasions, and the third column uses simulated data w/ 111 sampling occasions.

## ---------------------------------------------------------------------------------------
# Creating the data objects we need for all MCMC samples for Figure 4
## ---------------------------------------------------------------------------------------

## Function we will use
# The only argument we provide is 'j': this will be a value in {1, 2, 3} and represents the index of the objects we want to work with from the RData objects we have loaded in. If want objects generated using 18, 52 or 111 sampling occasions, j=1,2,3 respectively.
organise.data = function(j) {
  # Number of sampling occasions used for simulated data
  nocc  <- capthists_few_alloccs_3x3$noccasions[j]

  # Summing capture histories over all of the simulated sampling occasions
  all.dat <- capthists_few_alloccs_3x3$capthist[[j]]
  all.mat <- matrix(0, nrow=nrow(all.dat[,1,]), ncol=ncol(all.dat[,1,]))
  for (i in 1:nocc) {
    all.mat <- all.mat + all.dat[,i,]
  }

  # Trap locations
  trap.loc <- attributes(all.dat)$traps

4  # xlim, ylim (for our map area)
  xlim <- c(0.5, 50.5)
  ylim <- c(0.5, 50.5)

  # Creating the data object
  data <- list(encounter.data = all.mat, trap.loc = trap.loc, xlim = xlim, ylim = ylim, n.occasions = nocc)
  data
}

# Data object for 18 sampling occasions
data.18occ <- organise.data(1)

# Data object for 52 sampling occasions
data.52occ <- organise.data(2)

# Data object for 111 sampling occasions
data.111occ <- organise.data(3)

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 1 of Figure 4
## ---------------------------------------------------------------------------------------

## Row 1 consists of RACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is a homogeneous Poisson process. 

##### Running the MCMC #####

## Uncomment the lines below if want to run the MCMC 
## Running MCMC for simulated data from 18, 52 and 111 sampling occasions.
#results.18occ <- run.MCMC(data=data.18occ, M=300, parameters=c("lambda0", "coeff", "sigma", "N", "D", "z", "s"), n.iter=10000, n.burn=1000, lambda0.start=1, log_coeff.start=-5)
#save(results.18occ, file="MCMC_Results/Figure4/HomPP_18occ.RData")

#results.52occ <- run.MCMC(data=data.52occ, M=300, parameters=c("lambda0", "coeff", "sigma", "N", "D", "z", "s"), n.iter=10000, n.burn=1000, lambda0.start=1, log_coeff.start=-5)
#save(results.52occ, file="MCMC_Results/Figure4/HomPP_52occ.RData")

#results.111occ <- run.MCMC(data=data.111occ, M=300, parameters=c("lambda0", "coeff", "sigma", "N", "D", "z", "s"), n.iter=10000, n.burn=1000, lambda0.start=1, log_coeff.start=-5)
#save(results.111occ, file="MCMC_Results/Figure4/HomPP_111occ.RData")

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure4/HomPP_18occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/HomPP_52occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/HomPP_111occ.RData")

##### Creating the objects we need for the RACD plots #####

## Row 1 consists of RACD maps. So, we will create vectors that contain the posterior mean of the number of activity centres in each pixel -- these are the density values for each pixel in RACD maps that are based on MCMC results. 
racd.18occ <- no.movement.density.vector(results=results.18occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.52occ <-  no.movement.density.vector(results=results.52occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.111occ <- no.movement.density.vector(results=results.111occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 2 of Figure 4
## ---------------------------------------------------------------------------------------

## Row 2 consists of EACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is an inhomogeneous Poisson process.

##### 'pixel.info' object needed for MCMC #####

## Uncomment if want to run MCMC 
#pixel.centres <- centres(xlim=c(0.5,50.5), ylim=c(0.5,50.5), x.pixels=50, y.pixels=50)
#pixel.info <- cbind(pixel.centres, log.dblur)

##### Covariate value for each pixel #####

# Subsetting the covariate values from the data we loaded in above
mona.densities <-  small_blurry_mona_df[,c("x", "y", "Dblur")]
# Re-ordering 'mona.densities', so order of pixels matches order of pixels in 'pixel.centres' object (see above for creation of 'pixel.centres' object)
split <-  split(mona.densities, mona.densities$y)
mona.densities <-  do.call("rbind", split)
rownames(mona.densities) = NULL
# Now, subsetting "Dblur" vector only so is in corresponding order to centres in 'pixel.centres'
dblur <-  mona.densities[,"Dblur"]
# Logging the covariate, so we have the values of log(Dblur) (this is the covariate we will use to fit our SCR models)
log.dblur <-  log(dblur)

##### Running the MCMC #####

## Uncomment the lines below if want to run the MCMC. Note that depending on the computer, all of the MCMC chains below can take below 5 or 10 minutes to run. 
# 18 sampling occasions, saving the results 
#inhom.results.18occ <- run.MCMC.inhom(data=data.18occ, pixel.info=pixel.info, M=300, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
#save(inhom.results.18occ, file="MCMC_Results/Figure4/InhomPP_18occ.RData")

# 52 sampling occasions, saving the results
#inhom.results.52occ <- run.MCMC.inhom(data=data.52occ, pixel.info=pixel.info, M=300, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
#save(inhom.results.52occ, file="MCMC_Results/Figure4/InhomPP_52occ.RData")

# 111 sampling occasions, saving the results
#inhom.results.111occ <- run.MCMC.inhom(data=data.111occ, pixel.info=pixel.info, M=300, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
#save(inhom.results.111occ, file="MCMC_Results/Figure4/InhomPP_111occ.RData")

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_18occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_52occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_111occ.RData")

## So, discarding 1000 iterations as burn-in for our 3 MCMC samples
inhom.results.18occ <- inhom.results.18occ[-c(1:1000),]
inhom.results.52occ <- inhom.results.52occ[-c(1:1000),]
inhom.results.111occ <- inhom.results.111occ[-c(1:1000),]

##### Creating the objects we need for the EACD plots #####

## Creating vectors containing density values for each pixel when working with 18/52/111 sampling occasions
eacd.18occ <- eacd.density.vector(results=inhom.results.18occ, covariate=log.dblur, nPix=2500)
eacd.52occ <- eacd.density.vector(results=inhom.results.52occ, covariate=log.dblur, nPix=2500)
eacd.111occ <- eacd.density.vector(results=inhom.results.111occ, covariate=log.dblur, nPix=2500)

## ---------------------------------------------------------------------------------------
######################## Creating the objects needed for Figure 5 ########################
## ---------------------------------------------------------------------------------------

## In this figure, the first column uses simulated data w/ 7 sampling occasions. The second column uses simulated data w/ 25 sampling occasions, and the third column uses simulated data w/ 55 sampling occasions. 

## ---------------------------------------------------------------------------------------
# Creating the data objects we need for all MCMC samples for Figure 5
## ---------------------------------------------------------------------------------------

## Function we will use
# The only argument we provide is 'j': this will be a value in {1, 2, 3} and represents the index of the objects we want to work with from the RData objects we have loaded in. If want objects generated using 7, 25 or 55 sampling occasions, j=1,2,3 respectively.
organise.data = function(j) {
  # Number of sampling occasions used for simulated data
  nocc  <- capthists_few_alloccs_7x7$noccasions[j]

  # Summing capture histories over all of the simulated sampling occasions
  all.dat <- capthists_few_alloccs_7x7$capthist[[j]]
  all.mat <- matrix(0, nrow=nrow(all.dat[,1,]), ncol=ncol(all.dat[,1,]))
  for (i in 1:nocc) {
    all.mat <- all.mat + all.dat[,i,]
  }

  # Trap locations
  trap.loc <- attributes(all.dat)$traps

  # xlim, ylim (for our map area)
  xlim <- c(0.5, 50.5)
  ylim <- c(0.5, 50.5)

  # Creating the data object
  data <- list(encounter.data = all.mat, trap.loc = trap.loc, xlim = xlim, ylim = ylim, n.occasions = nocc)
  data
}

# Data object for 7 sampling occasions
data.7occ <- organise.data(1)

# Data object for 25 sampling occasions
data.25occ <- organise.data(2)

# Data object for 55 sampling occasions
data.55occ <- organise.data(3)

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 1 of Figure 5
## ---------------------------------------------------------------------------------------

## Row 1 consists of RACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is a homogeneous Poisson process.

##### Running the MCMC #####

## Uncomment the lines below if want to run the MCMC 
## Running MCMC for simulated data from 7, 25 and 55 sampling occasions.
#results.7occ <- run.MCMC(data=data.7occ, M=300, parameters=c("lambda0", "coeff", "sigma", "N", "D", "z", "s"), n.iter=10000, n.burn=1000, lambda0.start=1, log_coeff.start=-5)
#save(results.7occ, file="MCMC_Results/Figure5/HomPP_7occ.RData")

#results.25occ <- run.MCMC(data=data.25occ, M=300, parameters=c("lambda0", "coeff", "sigma", "N", "D", "z", "s"), n.iter=10000, n.burn=1000, lambda0.start=1, log_coeff.start=-5)
#save(results.25occ, file="MCMC_Results/Figure5/HomPP_25occ.RData")

#results.55occ <- run.MCMC(data=data.55occ, M=300, parameters=c("lambda0", "coeff", "sigma", "N", "D", "z", "s"), n.iter=10000, n.burn=1000, lambda0.start=1, log_coeff.start=-5)
#save(results.55occ, file="MCMC_Results/Figure5/HomPP_55occ.RData")

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure5/HomPP_7occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/HomPP_25occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/HomPP_55occ.RData")

##### Creating the objects we need for the RACD plots #####

## Row 1 consists of RACD maps. So, we will create vectors that contain the posterior mean of the number of activity centres in each pixel
racd.7occ <- no.movement.density.vector(results=results.7occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.25occ <-  no.movement.density.vector(results=results.25occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.55occ <- no.movement.density.vector(results=results.55occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 2 of Figure 5
## ---------------------------------------------------------------------------------------

## Row 2 consists of EACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is an inhomogeneous Poisson process.

##### 'pixel.info' object needed for MCMC #####

## Uncomment if want to run MCMC 
#pixel.centres <- centres(xlim=c(0.5,50.5), ylim=c(0.5,50.5), x.pixels=50, y.pixels=50)
#pixel.info <- cbind(pixel.centres, log.dblur)

##### Covariate value for each pixel #####
# Is 'log.dblur' object

##### Running the MCMC #####

## Uncomment the lines below if want to run the MCMC. Note that all of the MCMC chains below take below 10 minutes to run. 
# 7 sampling occasions, saving the results 
#inhom.results.7occ <- run.MCMC.inhom(data=data.7occ, pixel.info=pixel.info, M=300, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
#save(inhom.results.7occ, file="MCMC_Results/Figure5/InhomPP_7occ.RData")

# 25 sampling occasions, saving the results
#inhom.results.25occ <- run.MCMC.inhom(data=data.25occ, pixel.info=pixel.info, M=300, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
#save(inhom.results.25occ, file="MCMC_Results/Figure5/InhomPP_25occ.RData")

# 55 sampling occasions, saving the results
#inhom.results.55occ <- run.MCMC.inhom(data=data.55occ, pixel.info=pixel.info, M=300, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
#save(inhom.results.55occ, file="MCMC_Results/Figure5/InhomPP_55occ.RData")

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_7occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_25occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_55occ.RData")

## Discarding 1000 iterations as burn-in for our 3 MCMC samples
inhom.results.7occ <- inhom.results.7occ[-c(1:1000),]
inhom.results.25occ <- inhom.results.25occ[-c(1:1000),]
inhom.results.55occ <- inhom.results.55occ[-c(1:1000),]

##### Creating the objects we need for the EACD plots #####

## Creating vectors containing density values for each pixel when working with 7/25/55 sampling occasions
eacd.7occ <- eacd.density.vector(results=inhom.results.7occ, covariate=log.dblur, nPix=2500)
eacd.25occ <- eacd.density.vector(results=inhom.results.25occ, covariate=log.dblur, nPix=2500)
eacd.55occ <- eacd.density.vector(results=inhom.results.55occ, covariate=log.dblur, nPix=2500)

## ---------------------------------------------------------------------------------------
########################### Objects needed for Figures 4 and 5  ##########################
## ---------------------------------------------------------------------------------------

##### Creating a data frame that contains all of the info required for both figures #####

## Creating a data frame, labelled 'predicted_densities_all', that summarises all of the information that we will use to create the plots included in Figures 4 and 5

## Function to summarise the data for the RACD maps
# The 'nocc' argument is the number of sampling occasions, and 'fig' is the number of the figure for which we wish to summarise data
racd.summary <- function(nocc, fig) {
  # Pixel centres that we are working with
  pixel.centres <- centres(xlim=c(0.5,50.5), ylim=c(0.5,50.5), x.pixels=50, y.pixels=50)
  # Name of array we are working with -- if Figure 4, the name is '3x3' and if Figure 5, the name is '7x7'
  if (fig==4) {
    array <- "3x3"
  } else {
    if (fig==5) {
      array <- "7x7"
    }
  }
  # Obtaining the values for the necessary RACD map
  racd.vals <- get(paste0("racd.", nocc, "occ")) 
  # Data frame of information we want
  dat <- data.frame(x=pixel.centres[,1], y=pixel.centres[,2], covtype=rep("D~1", 2500), occasions=rep(nocc, 2500), array_size=rep(array, 2500), value=racd.vals)
  # Returning this data frame
  dat
}

## Function to summarise the data for the EACD maps -- arguments are the same as the function above
eacd.summary <- function(nocc, fig) {
  pixel.centres <- centres(xlim=c(0.5,50.5), ylim=c(0.5,50.5), x.pixels=50, y.pixels=50)
  if (fig==4) {
    array <- "3x3"
  } else {
    if (fig==5) {
      array <- "7x7"
    }
  }
  eacd.vals <- get(paste0("eacd.", nocc, "occ")) 
  dat <- data.frame(x=pixel.centres[,1], y=pixel.centres[,2], covtype=rep("D~log(Dblur)", 2500), occasions=rep(nocc, 2500), array_size=rep(array, 2500), value=eacd.vals)
  dat
}

## Function to create the final 'predicted_densities_all' object
# Here, 'nocc' is the vector of sampling occasions we are working with; 'fig' is the corresponding figure number for each map; 'type' is the corresponding type of map we want to create (enter as 'RACD' or 'EACD')
overall.summary <- function(nocc, fig, type) {
  # Initialising data frame
  dat <- data.frame()
  for (i in 1:length(nocc)) {
    # If type="RACD", creating a data frame summarising the info for the RACD map corresponding to the given number of sampling occasions and given figure number
    if (type[i]=="RACD") {
      dat.add <- racd.summary(nocc=nocc[i], fig=fig[i])
    } else {
      # If type="EACD", creating a data frame summarising the info for the EACD map
      if (type[i]=="EACD") {
        dat.add <- eacd.summary(nocc=nocc[i], fig=fig[i])
      }
    }
    # Adding the data frame created by racd.summary() or eacd.summary() to our 'dat' data frame
    dat <- rbind(dat, dat.add)
  }
  # Returning the final data frame
  dat
}

## Creating the 'predicted_densities_all' data frame
nocc <- c(rep(c(18, 52, 111), 2), rep(c(7, 25, 55), 2))
fig <- c(rep(4, 6), rep(5, 6))
type <- c(rep(c(rep("RACD", 3), rep("EACD", 3)), 2))
predicted_densities_all <- overall.summary(nocc=nocc, fig=fig, type=type)

##### Object that contains information about the detectors in both figures #####

detectors_df_all <- res_acd %>% purrr::map_depth(1, "detectors_df") %>% map_df(bind_rows)
detectors_df_all <- detectors_df_all %>% distinct()

##### Defining the max value of the colour scale #####

## We want this value to be the same for both Figures 4 and 5.

nn <- 3 # Number of simulated datasets we use in each figure  
xx <- predicted_densities_all %>% filter(array_size == "3x3", occasions %in% capthists_few_alloccs_3x3$noccasions[1:nn])
maxval1 <- max(xx$value) # Max density value found across all plots in Figure 4
xx <- predicted_densities_all %>% filter(array_size == "7x7", occasions %in% capthists_few_alloccs_7x7$noccasions[1:nn])
maxval2 <- max(xx$value) # Max density value found across all plots in Figure 5
maxval <- max(maxval1, maxval2) # Using the higher of these two max values as the top value of the colour scale for plots in both figures

## ---------------------------------------------------------------------------------------
################################### Creating Figure 4 ####################################
## ---------------------------------------------------------------------------------------

##### Adding the column and row labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects #####

nn <- 3 # Number of different simulated datasets used in Figure 4
occ <- capthists_few_alloccs_3x3$noccasions # Number of sampling occasions for each dataset
asz <- c("3x3")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_3x3$capthist, summary, terse = TRUE)))
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist() # Column lables for Figure 4

## Adding the column labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$occasions2 <- factor(predicted_densities_all$occasions, 
                                             levels = occ,
                                             labels = capthist_labels)
detectors_df_all$occasions2 <- factor(detectors_df_all$occasions, 
                                      levels = occ,
                                      labels = capthist_labels)

## Adding the row labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$covtype2 <- factor(predicted_densities_all$covtype, 
                                           levels = unique(predicted_densities_all$covtype),
                                           labels = c("Realised AC", "Expected AC"))
detectors_df_all$covtype2 <- factor(detectors_df_all$covtype, 
                                    levels = unique(detectors_df_all$covtype),
                                    labels = c("Realised AC", "Expected AC"))

##### Creating and saving Figure 4 #####

p2a <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller() + 
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

p2a
@

<<fig9, echo = FALSE, include = TRUE, fig.cap = "A version of Figure 5 from the manuscript based on our Bayesian models fitted via MCMC.", message=FALSE, fig.width=10, warning=FALSE, results=hide, fig=TRUE>>=
## ---------------------------------------------------------------------------------------
################################### Creating Figure 5 ####################################
## ---------------------------------------------------------------------------------------

##### Adding the column and row labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects #####

nn <- 3
occ <-capthists_few_alloccs_7x7$noccasions
asz <- c("7x7")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_7x7$capthist, summary, terse = TRUE)))
chs <- chs %>% dplyr::filter(Occasions %in% occ)
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist()

## Adding the column labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$occasions2 <- factor(predicted_densities_all$occasions, 
                                             levels = occ,
                                             labels = capthist_labels)
detectors_df_all$occasions2 <- factor(detectors_df_all$occasions, 
                                      levels = occ,
                                      labels = capthist_labels)

## Adding the row labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$covtype2 <- factor(predicted_densities_all$covtype, 
                                           levels = unique(predicted_densities_all$covtype),
                                           labels = c("Realised AC", "Expected AC"))
detectors_df_all$covtype2 <- factor(detectors_df_all$covtype, 
                                    levels = unique(detectors_df_all$covtype),
                                    labels = c("Realised AC", "Expected AC"))

##### Creating and saving Figure 5 #####

p2b <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller() + 
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  theme_bw(base_size = 14) +
  coord_equal() +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

p2b
@

\section{Realised usage density}

Estimation of realised usage density is a similar process for both
maximum likelihood and Bayesian approaches: we sum usage densities for
each individual animal, each of which is calculated by convolving the
posterior probability density function of its activity centre with an
individual usage distribution.

\subsection{The maximum likelihood approach}

For maximum likelihood, the estimated usage density for the $i$th
animal, with capture history $\bm{\omega}_i$, is given by
\begin{equation}
f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid \bm{\omega}_i; \bm{\widehat{\theta}}) =
\int f_{\bm{x} \mid \bm{\omega}}(\bm{x} \mid \bm{\omega}_i; \bm{\widehat{\theta}})
f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \bm{\widehat{\theta}}) d\bm{x}, \label{eq:ind-usage}
\end{equation}
where
\begin{itemize}
\item $\bm{\widehat{\theta}}$ is a vector containing the maximum
  likelihood estimates of the encounter function parameters;
\item $f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid
  \bm{\omega}_i; \bm{\widehat{\theta}})$ is the estimated usage distribution, providing the
  probability density of finding an individual with capture history
  $\bm{\omega}_i$ at location $\bm{s}$ at a randomly selected point in
  time;
\item $f_{\bm{x} \mid \bm{\omega}}(\bm{x} \mid \bm{\omega}_i;
  \bm{\widehat{\theta}})$ is the estimated PDF of the activity centre
  of an individual with capture history $\bm{\omega}_i$ (see Section
  3); and
\item $f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \bm{\widehat{\theta}})$ is the
  estimated usage distribution of the individual conditional on the
  activity centre, providing the probability density of the individual
  being at location $\bm{s}$ given that its activity centre is at
  $\bm{x}$.
\end{itemize}
Estimated usage density at location $\bm{s}$ is then given by
$\widehat{D}_u(\bm{s}) = \sum_i f_{\bm{s} \mid
  \bm{\omega}}(\bm{s} \mid \bm{\omega}_i; \bm{\widehat{\theta}})$, noting that the sum is
over individuals that were not detected, with capture histories $(0,
\cdots, 0)$, along with those that were.

Here we constructed the individual usage distribution under the
assumption that the density of an individual being at location
$\bm{s}$ given its activity centre is at $\bm{x}$ is proportional to
the encounter function $h\{d(\bm{s}, \bm{x});
\widehat{\bm{\theta}}\}$, where $d(\bm{s}, \bm{x})$ is the Euclidean
distance between $\bm{s}$ and $\bm{x}$, and so
\begin{equation}
  f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \widehat{\bm{\theta}}) = \frac{h\{d(\bm{s}, \bm{x}); \widehat{\bm{\theta}}\}}{\int h\{d(\bm{s}^\prime, \bm{x}); \widehat{\bm{\theta}}\} d\bm{s}^\prime},
\end{equation}
where the denominator is a normalising constant.

\subsection{The Bayesian approach}

Bayesian models fitted via MCMC can directly sample activity centres
of detected individuals, and also of undetected individuals using data
augmentation, thus obtaining samples from $f_{\bm{x} \mid
  \bm{\omega}}(\bm{x} \mid \bm{\omega})$ for each individual. We can
use these samples directly to obtain the following approximation of
the $i$th individual's usage distribution:
\begin{equation}
  f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid \bm{\omega}_i) \approx
  \frac{1}{J} \sum_{j = 1}^J f_{\bm{s} \mid \bm{x}}(\bm{s} \mid
  \bm{x}_{(j)}, \bm{\theta}_{(j)}),
\end{equation}
where $\bm{x}_{(j)}$ and $\bm{{\theta}}_{(j)}$ are the activity centre
and a vector of encounter function parameters that were sampled on the
$j$th of $J$ total MCMC iterations, respectively. The estimated usage
distribution is therefore not conditional on one particular set of
estimated parameter values, but instead considers the range of values
across the posterior distribution of $\bm{\theta}$.

% \subsection{Discussion}
% 
% \todo[inline]{I'm not sure that this is the best place for the
%   discussion below, but leaving it here for now.}
% 
% We constructed individual usage distributions using the encounter
% function from our SCR model, but this may not always be
% appropriate. For example, if individuals cannot fully explore their
% home range within the duration of the survey, then we would not expect
% the spatial range of the detection function to match the extent of an
% animal's usage distribution.
% 
% Even for longer surveys, it may not be sensible to relate the range of
% the encounter function to the size of the region used by an individual
% even for longer surveys, so care should be taken when this practice is
% used. For example, \citet{Tenan+al:17} found that the spatial scale of
% the encounter rate function for brown bears (\emph{Ursus arctos})
% estimated using SCR was not consistent with spatial usage parameters
% estimated from other data sources, although \citet{Popescu+al:14} did
% not detect any such inconsistency for a population of fishers
% (\emph{Pekania pennanti}). If alternative data sources are available
% (e.g., telemetry, or opportunistic data such as hair or scat samples)
% they may be incoprorated for improved estimation of individual usage
% distributions \citep{Tenan+al:17}.
% 
% Our method also assumes that home ranges are circular, however their
% shapes are likely to be modified by variables relating to population
% and landscape connectivity \citep[see][for a review]{Drake+al:ip}.


\bibliographystyle{../mee} \bibliography{../monalisa}

\end{document}
