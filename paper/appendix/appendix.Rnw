\documentclass[10pt,a4paper]{article}
\usepackage{authblk}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{amsmath}
\usepackage{bm}
\usepackage[authoryear,round, longnamesfirst]{natbib}
\usepackage{textcomp}
\usepackage{setspace}
\doublespacing
\usepackage{fancyhdr}
\usepackage[]{todonotes}
\presetkeys{todonotes}{fancyline, color=white}{}

\pagestyle{fancy}
\rhead{That's not the Mona Lisa}
\lhead{}

\usepackage{lineno}
\linenumbers
%\linespread{1.6}

\renewcommand{\thesection}{Appendix \Alph{section}}
\renewcommand{\thesubsection}{\Alph{section}\arabic{subsection}}
\renewcommand{\thefigure}{\Alph{section}\arabic{figure}}

\author[1,2,*]{Ian Durbach}
\author[3]{Rishika Chopara}
\author[1,2]{David L. Borchers}
\author[1]{Rachel Phillip}
\author[4]{Koustubh Sharma}
\author[3]{Ben C. Stevenson}

\affil[1]{\footnotesize Centre for Research into Ecological and Environmental Modelling, School of Mathematics and Statistics, Univeristy of St Andrews, The Observatory, St Andrews, Fife, KY16 9LZ, Scotland}
\affil[2]{\footnotesize Centre for Statistics in Ecology, the Environment and Conservation, Department of Statistical Sciences, University of Cape Town, South Africa}
\affil[3]{\footnotesize Department of Statistics, University of Auckland, Auckland 1010, New Zealand}
\affil[4]{\footnotesize Snow Leopard Trust, Seattle, Washington, United States of America}
\affil[*]{\footnotesize Corresponding author: indurbach@gmail.com}

\date{}

\title{Supplementary Material: That's not the Mona Lisa! How to interpret spatial capture-recapture density surface estimates}


\begin{document}

\maketitle

\section{Bayesian models}

Results presented in Section 4 in our manuscript were generated by
fitting maximum-likelihood SCR models to simulated data. In this
appendix we reproduce results from Section 4 using Bayesian models
fitted via MCMC to demonstrate that our conclusions are not simply a
consequence of adopting a classical approach. We have reproduced
Figures 4 and 5 below. 

In Section \ref{sec:appendix-model-fitting} we describe our Bayesian
models, and in Section \ref{sec:appendix-results} we summarize our
results. 

\subsection{Model fitting}
\label{sec:appendix-model-fitting}

We fitted Bayesian versions of the maximum-likelihood models presented
in Section 4 to each data set. Again, we used models with constant
density to estimate realized AC and realized usage surfaces, and a
model with inhomogeneous density characterized by a log-linear
relationship with a spatial covariate to estimate expected AC density
surfaces.

We fitted our models in NIMBLE \citep{deValpine:17, Turek:21} using
data augmentation \citep{Tanner:87}, which has become the prevailing
way to fit SCR models under a Bayesian framework. This approach
involves sampling a superpopulation of $M$ activity centres, including
those of the $n$ animals detected on the SCR survey. We have an
indicator variable $z_i$ for the $i$th animal, denoting whether the
$i$th animal in the augmented population `exists' in a given MCMC
iteration. Rather than directly estimating $N$, the population size,
we estimate the data augmentation parameter, $\psi$, the proportion of
the animals in the superpopulation for which the indicator is equal to
1. For each MCMC iteration we obtain a sample from the posterior of
$N$ using $\sum_{\i = 1}^M z_i$. A sample from the posterior for
animal density can be obtained by dividing each estimate of $N$ by the area of the survey
region. Further details on data augmentation can be found in
\citet[][pp.\ 139--157]{Kery+Schaub:12}.

We used the following uninformative priors for the detection function
parameters, specifying a prior for $\log\{1/(2\sigma^2)\}$ rather than
$\sigma$ directly:
\begin{align*}
  \lambda_0 &\sim \text{Gamma}(0.001, 0.001) \\
  \log\left(\frac{1}{2\sigma^2}\right) &\sim \text{Uniform}(-10, 10)
\end{align*}

For the constant density model, the activity centres were given a
uniform prior distribution over the survey region and the data
augmentation parameter was given a uniform prior from 0 to 1. For the
inhomogeneous density model, we used the following uninformative
priors for the coefficients $\beta_0$ and $\beta_1$:
\begin{align*}
\beta_0 &\sim \text{Uniform}(-10, 10) \\
\beta_1 &\sim \text{Uniform}(-10, 10)
\end{align*}

When we fit each constant density model, we ran 11\,000 MCMC
iterations, where we set M to be equal to 300. We also used an
adaptation interval of 1000, and discarded 1000 iterations as burn-in.

When fitting each inhomogeneous density model, we ran 101\,000 MCMC
iterations, and used a value of 300 for M. We didn't use an
adaptation interval, and discarded 1000 iterations as burn-in.

\subsection{Results}
\label{sec:appendix-results}

We created trace plots for all parameters across all models, and none
of them indicated a lack of convergence. Although we do not present
them here for brevity, the point estimates (calculated using the
posterior mean) of all parameters were similar to those obtained
via maximum likelihood models fitted to the same data. In addition,
the 95\% credible intervals for the parameters were similar to the
95\% confidence intervals found via maximum likelihood models. 

The plots based on our Bayesian models fitted via MCMC (Figures
\ref{fig:fig4} and \ref{fig:fig5}, respectively) were qualitatively
similar to those based on maximum likelihood models (respectively,
Figure 4 and Figure 5). A
potential explanation for any subtle differences is that our Bayesian
plots are constructed based on entire posterior distributions, whereas
the maximum likelihood alternatives only use point estimates.

<<fig4, echo = FALSE, include = TRUE, fig.cap = "A version of Figure 4 from the manuscript based on our Bayesian models fitted via MCMC.", message=FALSE, fig.width=10, warning=FALSE, results='hide'>>=
## Libraries we need
library(ggplot2)
library(dplyr)
library(stringr)
library(purrr)
library(patchwork)
library(ggpubr)
library(secr)
load("../../output/revision/mona-inputs.RData")
load("../../output/revision/mona-results.RData")

## Loading in the data frame that we'll be using
load("fig4_fig5.RData")

## Loading in data on the detectors
load("detectors.RData")

## Defining the max value of the colour scale
## We want this value to be the same for both Figures 4 and 5
nn <- 3 # Number of simulated datasets we use in each figure
xx <- predicted_densities_all %>% filter(array_size == "3x3", occasions %in% capthists_few_alloccs_3x3$noccasions[1:nn])
maxval1 <- max(xx$value) # Max density value found across all plots in Figure 4
xx <- predicted_densities_all %>% filter(array_size == "7x7", occasions %in% capthists_few_alloccs_7x7$noccasions[1:nn])
maxval2 <- max(xx$value) # Max density value found across all plots in Figure 5
maxval <- max(maxval1, maxval2) # Using the higher of these two max values as the top value of the colour scale for plots in both figures

## Creating Figure 4 ##

nn <- 3 # Number of different simulated datasets used in Figure 4
occ <- capthists_few_alloccs_3x3$noccasions # Number of sampling occasions for each dataset
asz <- c("3x3")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_3x3$capthist, summary, terse = TRUE)))
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist() # Column lables for Figure 4

## Adding the column labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$occasions2 <- factor(predicted_densities_all$occasions,
                                             levels = occ,
                                             labels = capthist_labels)
detectors_df_all$occasions2 <- factor(detectors_df_all$occasions,
                                      levels = occ,
                                      labels = capthist_labels)

## Adding the row labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$covtype2 <- factor(predicted_densities_all$covtype,
                                           levels = unique(predicted_densities_all$covtype),
                                           labels = c("Realised AC", "Expected AC"))
detectors_df_all$covtype2 <- factor(detectors_df_all$covtype,
                                    levels = unique(detectors_df_all$covtype),
                                    labels = c("Realised AC", "Expected AC"))

## Plotting Figure 4

fig4 <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) +
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA),
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

fig4
@

<<fig5, echo = FALSE, include = TRUE, fig.cap = "A version of Figure 5 from the manuscript based on our Bayesian models fitted via MCMC.", message=FALSE, fig.width=10, warning=FALSE, results='hide'>>=
## Creating Figure 5 ##

nn <- 3
occ <-capthists_few_alloccs_7x7$noccasions
asz <- c("7x7")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_7x7$capthist, summary, terse = TRUE)))
chs <- chs %>% dplyr::filter(Occasions %in% occ)
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist()

## Adding the column labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$occasions2 <- factor(predicted_densities_all$occasions,
                                             levels = occ,
                                             labels = capthist_labels)
detectors_df_all$occasions2 <- factor(detectors_df_all$occasions,
                                      levels = occ,
                                      labels = capthist_labels)

## Adding the row labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$covtype2 <- factor(predicted_densities_all$covtype,
                                           levels = unique(predicted_densities_all$covtype),
                                           labels = c("Realised AC", "Expected AC"))
detectors_df_all$covtype2 <- factor(detectors_df_all$covtype,
                                    levels = unique(detectors_df_all$covtype),
                                    labels = c("Realised AC", "Expected AC"))

## Plotting Figure 5

fig5 <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) +
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  theme_bw(base_size = 14) +
  coord_equal() +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA),
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

fig5
@

\section{Uncertainty surfaces}
\label{sec:uncertainty}

Here we present surfaces that convey the uncertainty present in the
expected AC density surface estimates shown in \ref{fig:fig4} and
\ref{fig:fig5}. The left and right columns of Figures
\ref{fig:fig4-uncertainty} and \ref{fig:fig5-uncertainty} show the
lower- and upper-limits of 90\% credible intervals, using the 5\% and
95\% quantiles of the posterior distribution for the expected AC
density in each pixel. The middle column shows the expected AC density
surface estimates from \ref{fig:fig4} and \ref{fig:fig5}, using the
posterior mean for each pixel. For a frequentist analysis, calculating
measures of uncertainty (standard errors and confidence intervals) can
be achieved using the delta method or a bootstrap, for example.

We also considered uncertainty in realized AC density surface
estimates. For a Bayesian analysis, we can approximate the posterior
distribution of a pixel's realized AC density by counting the number
of ACs within the pixel on each MCMC iteration, and dividing by the
area of the pixel. For a frequentist analysis, defining and
calculating uncertainty is more complicated: both the delta method and
the bootstrap are designed to calculate variance of estimates across
multiple realizations of the AC point process, but realized AC density
surfaces are specific a single realization.

Here we consider both the posterior standard deviation the coefficient
of variation (CV) as a relative measures of uncertainty. The CV is
calculated by dividing the standard deviation of the posterior
distribution by the mean. In Figure \ref{fig:fig4-plot1-cv}, we
display posterior standard deviations and CVs for the realized AC
density surface estimate shown in the top-left panel of Figure
\ref{fig:fig4}. We calculated these measures of uncertainty for three
different pixel sizes: squares with edges of 1 distance unit, 2 units,
and 5 units, respectively.

Spatial patterns in posterior standard deviation reflected the
estimated surface, because pixels that tend to have higher counts of
ACs in pixels inherently have more variation across iterations. The CV
measures relative rather than absolute uncertainty, thus correcting
for differences in uncertainty across pixels caused by variation in
the posterior mean. The spatial patterns in CV were the opposite of
those for the posterior standard deviation, with highest levels of
relative uncertainty in the pixels with the smallest estimates of
realized AC density.

We found that uncertainty in realized AC density was sensitive to
pixel size. Using smaller pixels results in larger uncertainty due to
smaller samples of ACs within the pixel across the MCMC iterations,
while for larger pixels the relative number of ACs per unit area
within a pixel is more stable.

We do not get the same result for uncertainty in expected AC density
surface estimates, because these deal with the expected (rather than
observed) number of ACs per unit area in the pixel. The CVs for
expected AC density estimates are substantially lower than for
realized AC density estimates, because estimating the mean of a
distribution can be achieved more accurately than predicting a
realization from that distribution. Predicting outcomes of random
variables requires that we account for the variance of the
distribution itself, in addition to variation due to uncertainty in
estimating the mean.

<<fig4-uncertainty, echo = FALSE, include = TRUE, fig.cap = "Plots visualising the uncertainty present in the expected activity centre surfaces from Figure 4.", message=FALSE, fig.width=8, warning=FALSE, results='hide'>>=
## For each EACD plot in Figures 4 and 5, we will create two uncertainty plots: one showing the lower 5% quantile for the posterior distribution of the density for each pixel, the other will show the upper 95% quantile.

## Loading in the data that we need
load("uncertainty_plots.RData")

## Loading in data on the detectors
load("detectors.RData")

## Maximum value for colour scale for *all* plots
maxval <- max(values_all$value)

## Creating the uncertainty figure for Figure 4 ##

nn <- 3 # Number of different simulated datasets used in Figure 4
occ <- capthists_few_alloccs_3x3$noccasions # Number of sampling occasions for each dataset
asz <- c("3x3")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_3x3$capthist, summary, terse = TRUE)))
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist() # Row labels we'll use

## Adding faceting info to 'values_all' for rows that we will use in this uncertainty figure
values_all$covtype2 <- factor(values_all$covtype, levels=unique(values_all$covtype),
                              labels=c("Expected AC"))
values_all$quantile <- factor(rep(c(rep("0.05 quantile", 2500), rep("Mean", 2500), rep("0.95 quantile", 2500)), 3),
                              levels=c("0.05 quantile", "Mean", "0.95 quantile"))
values_all$occasions2 <- factor(values_all$occasions,
                                levels = occ,
                                labels = capthist_labels)

## Plotting the uncertainty figure
uncertainty.fig4 <- values_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) +
  facet_grid(occasions2 ~ quantile) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA),
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

uncertainty.fig4
@

<<fig5-uncertainty, echo = FALSE, include = TRUE, fig.cap = "Plots visualising the uncertainty present in the expected activity centre surfaces from Figure 5.", message=FALSE, fig.width=8, warning=FALSE, results='hide'>>=
## Creating the uncertainty figure for Figure 5 ##

nn <- 3
occ <-capthists_few_alloccs_7x7$noccasions
asz <- c("7x7")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_7x7$capthist, summary, terse = TRUE)))
chs <- chs %>% dplyr::filter(Occasions %in% occ)
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist()

## Adding faceting info for rows that we will use to create this uncertainty figure
values_all$occasions2 <- factor(values_all$occasions,
                                levels = occ,
                                labels = capthist_labels)

## Plotting the uncertainty figure
uncertainty.fig5 <- values_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) +
  facet_grid(occasions2 ~ quantile) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA),
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

uncertainty.fig5
@

<<fig4-plot1-cv, echo = FALSE, include = TRUE, fig.cap = "Plots visualising how the CV and posterior standard deviation values change as pixel size changes, using the the leftmost RACD surface in Figure 4.", message=FALSE, fig.width=8, warning=FALSE, results='hide'>>=
## FIRST, working on the plots that show the CV values
# Loading in the data that we need
load("cv_plots.RData")
load("detectors_cv_plots.RData")

# Max CV value across all 3 plots
maxval <- max(cv_values_all$value)

# Creating the CV Figure
cv_values_all$valtype <- factor(rep("Realised AC CV (%)", nrow(cv_values_all)))
nn <- 3
asz <- c("3x3")
occ <- 18
racd.cv.fig  <-  cv_values_all %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0,maxval)) + 
  facet_grid(valtype ~ pixel.size) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.56, "cm"),
        legend.key.height = unit(0.9,"cm"), legend.title = element_blank(),
        panel.background=element_blank(), panel.border=element_blank(),panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(),plot.background=element_blank())

## NEXT, working on the plots that show the SD values
# Loading in the data
load("sd_plots.RData")

# Max SD value across all 3 plots
sdmaxval <- max(sd_values_all$value)

# Creating the SD figure
nn <- 3
asz <- c("3x3")
occ <- 18
racd.sd.fig  <-  sd_values_all %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0,sdmaxval), breaks=c(0, 0.1, 0.2), labels=c("0.00", "0.10", "0.20")) + 
  facet_grid(valtype ~ pixel.size) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.56, "cm"),
        legend.key.height = unit(0.9,"cm"), legend.title = element_blank(),
        panel.background=element_blank(), panel.border=element_blank(),panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(),plot.background=element_blank())
        
## NEXT, creating corresponding RACD
# Loading in the data we need
load("racd_18occ.RData")

# Max density value, setting it to be the same as Figures 4 and 5
maxval <- 0.2301

# Creating the RACD plot
nn <- 3
occ <- 18
asz <- c("3x3")
fig4.18occ <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) + 
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.56, "cm"),
        legend.key.height = unit(0.9,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())
        
## Putting together the whole figure
# One possible configuration
ggarrange(fig4.18occ, ggarrange(racd.cv.fig, racd.sd.fig, nrow=2), nrow=2, heights=c(1.1, 2))
# Another
#ggarrange(fig4.18occ, ggarrange(racd.cv.fig, racd.sd.fig, nrow=2), ncol=2, widths=c(1, 2))
@ 

%% \section{Realised usage density}

%% Estimation of realised usage density is a similar process for both
%% maximum likelihood and Bayesian approaches: we sum usage densities for
%% each individual animal, each of which is calculated by convolving the
%% posterior probability density function of its activity centre with an
%% individual usage distribution.

%% \subsection{The maximum likelihood approach}

%% For maximum likelihood, the estimated usage density for the $i$th
%% animal, with capture history $\bm{\omega}_i$, is given by
%% \begin{equation}
%% f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid \bm{\omega}_i; \bm{\widehat{\theta}}) =
%% \int f_{\bm{x} \mid \bm{\omega}}(\bm{x} \mid \bm{\omega}_i; \bm{\widehat{\theta}})
%% f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \bm{\widehat{\theta}}) d\bm{x}, \label{eq:ind-usage}
%% \end{equation}
%% where
%% \begin{itemize}
%% \item $\bm{\widehat{\theta}}$ is a vector containing the maximum
%%   likelihood estimates of the encounter function parameters;
%% \item $f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid
%%   \bm{\omega}_i; \bm{\widehat{\theta}})$ is the estimated usage distribution, providing the
%%   probability density of finding an individual with capture history
%%   $\bm{\omega}_i$ at location $\bm{s}$ at a randomly selected point in
%%   time;
%% \item $f_{\bm{x} \mid \bm{\omega}}(\bm{x} \mid \bm{\omega}_i;
%%   \bm{\widehat{\theta}})$ is the estimated PDF of the activity centre
%%   of an individual with capture history $\bm{\omega}_i$ (see Section
%%   3); and
%% \item $f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \bm{\widehat{\theta}})$ is the
%%   estimated usage distribution of the individual conditional on the
%%   activity centre, providing the probability density of the individual
%%   being at location $\bm{s}$ given that its activity centre is at
%%   $\bm{x}$.
%% \end{itemize}
%% Estimated usage density at location $\bm{s}$ is then given by
%% $\widehat{D}_u(\bm{s}) = \sum_i f_{\bm{s} \mid
%%   \bm{\omega}}(\bm{s} \mid \bm{\omega}_i; \bm{\widehat{\theta}})$, noting that the sum is
%% over individuals that were not detected, with capture histories $(0,
%% \cdots, 0)$, along with those that were.

%% Here we constructed the individual usage distribution under the
%% assumption that the density of an individual being at location
%% $\bm{s}$ given its activity centre is at $\bm{x}$ is proportional to
%% the encounter function $h\{d(\bm{s}, \bm{x});
%% \widehat{\bm{\theta}}\}$, where $d(\bm{s}, \bm{x})$ is the Euclidean
%% distance between $\bm{s}$ and $\bm{x}$, and so
%% \begin{equation}
%%   f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \widehat{\bm{\theta}}) = \frac{h\{d(\bm{s}, \bm{x}); \widehat{\bm{\theta}}\}}{\int h\{d(\bm{s}^\prime, \bm{x}); \widehat{\bm{\theta}}\} d\bm{s}^\prime},
%% \end{equation}
%% where the denominator is a normalising constant.

%% \subsection{The Bayesian approach}

%% Bayesian models fitted via MCMC can directly sample activity centres
%% of detected individuals, and also of undetected individuals using data
%% augmentation, thus obtaining samples from $f_{\bm{x} \mid
%%   \bm{\omega}}(\bm{x} \mid \bm{\omega})$ for each individual. We can
%% use these samples directly to obtain the following approximation of
%% the $i$th individual's usage distribution:
%% \begin{equation}
%%   f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid \bm{\omega}_i) \approx
%%   \frac{1}{J} \sum_{j = 1}^J f_{\bm{s} \mid \bm{x}}(\bm{s} \mid
%%   \bm{x}_{(j)}, \bm{\theta}_{(j)}),
%% \end{equation}
%% where $\bm{x}_{(j)}$ and $\bm{{\theta}}_{(j)}$ are the activity centre
%% and a vector of encounter function parameters that were sampled on the
%% $j$th of $J$ total MCMC iterations, respectively. The estimated usage
%% distribution is therefore not conditional on one particular set of
%% estimated parameter values, but instead considers the range of values
%% across the posterior distribution of $\bm{\theta}$.

% \subsection{Discussion}
%
% \todo[inline]{I'm not sure that this is the best place for the
%   discussion below, but leaving it here for now.}
%
% We constructed individual usage distributions using the encounter
% function from our SCR model, but this may not always be
% appropriate. For example, if individuals cannot fully explore their
% home range within the duration of the survey, then we would not expect
% the spatial range of the detection function to match the extent of an
% animal's usage distribution.
%
% Even for longer surveys, it may not be sensible to relate the range of
% the encounter function to the size of the region used by an individual
% even for longer surveys, so care should be taken when this practice is
% used. For example, \citet{Tenan+al:17} found that the spatial scale of
% the encounter rate function for brown bears (\emph{Ursus arctos})
% estimated using SCR was not consistent with spatial usage parameters
% estimated from other data sources, although \citet{Popescu+al:14} did
% not detect any such inconsistency for a population of fishers
% (\emph{Pekania pennanti}). If alternative data sources are available
% (e.g., telemetry, or opportunistic data such as hair or scat samples)
% they may be incoprorated for improved estimation of individual usage
% distributions \citep{Tenan+al:17}.
%
% Our method also assumes that home ranges are circular, however their
% shapes are likely to be modified by variables relating to population
% and landscape connectivity \citep[see][for a review]{Drake+al:ip}.


\bibliographystyle{../biom} \bibliography{../monalisa}

\end{document}
