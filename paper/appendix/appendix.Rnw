\documentclass[10pt,a4paper]{article}
\usepackage{authblk}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{amsmath}
\usepackage{bm}
\usepackage[authoryear,round, longnamesfirst]{natbib}
\usepackage{textcomp}
\usepackage{setspace}
\doublespacing
\usepackage{fancyhdr}
\usepackage[]{todonotes}
\presetkeys{todonotes}{fancyline, color=white}{}

\pagestyle{fancy}
\rhead{That's not the Mona Lisa}
\lhead{}

\usepackage{lineno}
\linenumbers
%\linespread{1.6}

\renewcommand{\thesection}{Appendix \Alph{section}}
\renewcommand{\thesubsection}{\Alph{section}\arabic{subsection}}
\renewcommand{\thefigure}{\Alph{section}\arabic{figure}}  

\author[1,2,*]{Ian Durbach}
\author[3]{Rishika Chopara}
\author[1,2]{David L. Borchers}
\author[1]{Rachel Phillip}
\author[4]{Koustubh Sharma}
\author[3]{Ben C. Stevenson}

\affil[1]{\footnotesize Centre for Research into Ecological and Environmental Modelling, School of Mathematics and Statistics, Univeristy of St Andrews, The Observatory, St Andrews, Fife, KY16 9LZ, Scotland}
\affil[2]{\footnotesize Centre for Statistics in Ecology, the Environment and Conservation, Department of Statistical Sciences, University of Cape Town, South Africa}
\affil[3]{\footnotesize Department of Statistics, University of Auckland, Auckland 1010, New Zealand}
\affil[4]{\footnotesize Snow Leopard Trust, Seattle, Washington, United States of America}
\affil[*]{\footnotesize Corresponding author: indurbach@gmail.com}

\date{}

\title{Supplementary Material: That's not the Mona Lisa! How to interpret spatial capture-recapture density surface estimates}


\begin{document}

\maketitle

\section{Bayesian models}

Results presented in Section 4 in our manuscript were generated by
fitting maximum-likelihood SCR models to simulated data. In this
appendix we reproduce results from Section 4 using Bayesian models
fitted via MCMC to demonstrate that our conclusions are not simply a
consequence of adopting a classical approach. We focus on reproducing
Figures 5 and a single-simulation version of Figure 6 from the manuscript; other figures are based on averages over 100 simulations, which would require considerable
computation time given that fitting SCR models via MCMC is more time
consuming than maximum likelihood.

In Section \ref{sec:appendix-model-fitting} we describe our Bayesian
models, and in Section \ref{sec:appendix-results} we summarise our
results.

\subsection{Model fitting}
\label{sec:appendix-model-fitting}

We fitted Bayesian versions of the maximum-likelihood models presented
in Section 4 to each data set. Again, we used models with constant
density to estimate realised AC and realised usage surfaces, and a
model with inhomogeneous density characterised by a log-linear
relationship with a spatial covariate to estimate expected AC density
surfaces.

We fitted our models in NIMBLE \citep{deValpine:17, Turek:21} using
data augmentation \citep{Tanner:87}, which has become the prevailing
way to fit SCR models under a Bayesian framework. This approach
involves sampling a superpopulation of $M$ activity centres, including
those of the $n$ animals detected on the SCR survey. We have an
indicator variable $z_i$ for the $i$th animal, denoting whether the
$i$th animal in the augmented population `exists' in a given MCMC
iteration. Rather than directly estimating $N$, the population size,
we estimate the data augmentation parameter, $\psi$, the proportion of
the animals in the superpopulation for which the indicator is equal to
1. For each MCMC iteration we obtain a sample from the posterior of
$N$ using $\sum_{\i = 1}^M z_i$. A sample from the posterior for
animal density can be obtained by dividing each estimate of $N$ by the area of the survey
region. Further details on data augmentation can be found in
\citet[][pp.\ 139--157]{Kery+Schaub:12}.

We used the following uninformative priors for the detection function
parameters, specifying a prior for $\log\{1/(2\sigma^2)\}$ rather than
$\sigma$ directly:
\begin{align*}
  \lambda_0 &\sim \text{Gamma}(0.001, 0.001) \\
  \log\left(\frac{1}{2\sigma^2}\right) &\sim \text{Uniform}(-10, 10)
\end{align*}

For the constant density model, the activity centres were given a
uniform prior distribution over the survey region and the data
augmentation parameter was given a uniform prior from 0 to 1. For the
inhomogeneous density model, animal density at location $\bm{x}$ is
given by $D(\bm{x}) = \exp\{\beta_0 + \beta_1 y(\bm{x})\}$, where
$y(\bm{x})$ is a measurement of a covariate at location $\bm{x}$. We
used the following uninformative priors for the coefficients $\beta_0$
and $\beta_1$:
\begin{align*}
\beta_0 &\sim \text{Uniform}(-10, 10) \\
\beta_1 &\sim \text{Uniform}(-10, 10)
\end{align*}

When we fit each constant density model, we ran 11\,000 MCMC
iterations, where we set M to be equal to 300. We also used an
adaptation interval of 1000, and discarded 1000 iterations as burn-in.

When fitting each inhomogeneous density model, we ran 101\,000 MCMC
iterations, and used a value of 300 for M. We didn't use an
adaptation interval, and discarded 1000 iterations as burn-in.

\subsection{Results}
\label{sec:appendix-results}

We created trace plots for all parameters across all models, and none
of them indicated a lack of convergence. Although we do not present
them here for brevity, the point estimates (calculated using the
posterior mean) of all parameters were very similar to those obtained
via maximum likelihood models fitted to the same data.

The plots based on our Bayesian models fitted via MCMC (Figures
\ref{fig:fig4} and \ref{fig:fig5}, respectively) were qualitatively
similar to those based on maximum likelihood models (respectively, Figure 5 and a single-survey version of Figure 6 shown in\ref{fig:fig9-mle}). We observed that the
locations with the highest AC densities in Figure \ref{fig:fig9} were
shifted slightly further from the detectors, relative to Figure \ref{fig:fig9-mle}. A
potential explanation for subtle differences is that our Bayesian
plots are constructed based on entire posterior distributions, whereas
the maximum likelihood alternatives only use point estimates.

<<fig4, echo = FALSE, include = TRUE, fig.cap = "A version of Figure 4 from the manuscript based on our Bayesian models fitted via MCMC.", message=FALSE, fig.width=10, warning=FALSE, results=hide, fig=TRUE>>=
## Libraries we need
library(nimble)
library(coda)
library(nimbleSCR)
library(spatstat)
library(ggplot2)
library(dplyr)
library(stringr)
library(purrr)
library(secr)
library(patchwork)
library(ggpubr)
## Objects we need
load("../../output/revision/mona-inputs.RData")
load("../../output/revision/mona-results.RData")
## Functions we need
source("../../bayesian_code/Functions.R")

## ---------------------------------------------------------------------------------------
######################## Creating the objects needed for Figure 4 ########################
## ---------------------------------------------------------------------------------------

## In this figure, the first column uses simulated data w/ 18 sampling occasions. The second column uses simulated data w/ 52 sampling occasions, and the third column uses simulated data w/ 111 sampling occasions.

## ---------------------------------------------------------------------------------------
# Creating the data objects we need for all MCMC samples for Figure 4
## ---------------------------------------------------------------------------------------

## Function we will use
# The only argument we provide is 'j': this will be a value in {1, 2, 3} and represents the index of the objects we want to work with from the RData objects we have loaded in. If want objects generated using 18, 52 or 111 sampling occasions, j=1,2,3 respectively.
organise.data = function(j) {
  # Number of sampling occasions used for simulated data
  nocc  <- capthists_few_alloccs_3x3$noccasions[j]

  # Summing capture histories over all of the simulated sampling occasions
  all.dat <- capthists_few_alloccs_3x3$capthist[[j]]
  all.mat <- matrix(0, nrow=nrow(all.dat[,1,]), ncol=ncol(all.dat[,1,]))
  for (i in 1:nocc) {
    all.mat <- all.mat + all.dat[,i,]
  }

  # Trap locations
  trap.loc <- attributes(all.dat)$traps

4  # xlim, ylim (for our map area)
  xlim <- c(0.5, 50.5)
  ylim <- c(0.5, 50.5)

  # Creating the data object
  data <- list(encounter.data = all.mat, trap.loc = trap.loc, xlim = xlim, ylim = ylim, n.occasions = nocc)
  data
}

# Data object for 18 sampling occasions
data.18occ <- organise.data(1)

# Data object for 52 sampling occasions
data.52occ <- organise.data(2)

# Data object for 111 sampling occasions
data.111occ <- organise.data(3)

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 1 of Figure 4
## ---------------------------------------------------------------------------------------

## Row 1 consists of RACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is a homogeneous Poisson process. 

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure4/HomPP_18occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/HomPP_52occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/HomPP_111occ.RData")
## Note that the burn-in iterations for these samples are discarded automatically, so we don't need to worry about this.

##### Creating the objects we need for the RACD plots #####

## Row 1 consists of RACD maps. So, we will create vectors that contain the posterior mean of the number of activity centres in each pixel -- these are the density values for each pixel in RACD maps that are based on MCMC results. 
racd.18occ <- no.movement.density.vector(results=results.18occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.52occ <-  no.movement.density.vector(results=results.52occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.111occ <- no.movement.density.vector(results=results.111occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 2 of Figure 4
## ---------------------------------------------------------------------------------------

## Row 2 consists of EACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is an inhomogeneous Poisson process.

##### Covariate value for each pixel #####

# Note, see 'Functions.R' for an explanation of this function. It basically just working with the data objects we have loaded into R by this point to extract the covariate values for each pixel. 
log.dblur <- eacd.covariate()

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_18occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_52occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_111occ.RData")
# Discarding burn-in
inhom.results.18occ <- inhom.results.18occ[-c(1:1000),]
inhom.results.52occ <- inhom.results.52occ[-c(1:1000),]
inhom.results.111occ <- inhom.results.111occ[-c(1:1000),]

##### Creating the objects we need for the EACD plots #####

## Creating vectors containing density values for each pixel when working with 18/52/111 sampling occasions
eacd.18occ <- eacd.density.vector(results=inhom.results.18occ, covariate=log.dblur, nPix=2500)
eacd.52occ <- eacd.density.vector(results=inhom.results.52occ, covariate=log.dblur, nPix=2500)
eacd.111occ <- eacd.density.vector(results=inhom.results.111occ, covariate=log.dblur, nPix=2500)

## ---------------------------------------------------------------------------------------
######################## Creating the objects needed for Figure 5 ########################
## ---------------------------------------------------------------------------------------

## In this figure, the first column uses simulated data w/ 7 sampling occasions. The second column uses simulated data w/ 25 sampling occasions, and the third column uses simulated data w/ 55 sampling occasions. 

## ---------------------------------------------------------------------------------------
# Creating the data objects we need for all MCMC samples for Figure 5
## ---------------------------------------------------------------------------------------

## Function we will use
# The only argument we provide is 'j': this will be a value in {1, 2, 3} and represents the index of the objects we want to work with from the RData objects we have loaded in. If want objects generated using 7, 25 or 55 sampling occasions, j=1,2,3 respectively.
organise.data = function(j) {
  # Number of sampling occasions used for simulated data
  nocc  <- capthists_few_alloccs_7x7$noccasions[j]

  # Summing capture histories over all of the simulated sampling occasions
  all.dat <- capthists_few_alloccs_7x7$capthist[[j]]
  all.mat <- matrix(0, nrow=nrow(all.dat[,1,]), ncol=ncol(all.dat[,1,]))
  for (i in 1:nocc) {
    all.mat <- all.mat + all.dat[,i,]
  }

  # Trap locations
  trap.loc <- attributes(all.dat)$traps

  # xlim, ylim (for our map area)
  xlim <- c(0.5, 50.5)
  ylim <- c(0.5, 50.5)

  # Creating the data object
  data <- list(encounter.data = all.mat, trap.loc = trap.loc, xlim = xlim, ylim = ylim, n.occasions = nocc)
  data
}

# Data object for 7 sampling occasions
data.7occ <- organise.data(1)

# Data object for 25 sampling occasions
data.25occ <- organise.data(2)

# Data object for 55 sampling occasions
data.55occ <- organise.data(3)

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 1 of Figure 5
## ---------------------------------------------------------------------------------------

## Row 1 consists of RACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is a homogeneous Poisson process.

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure5/HomPP_7occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/HomPP_25occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/HomPP_55occ.RData")
## Note that the burn-in iterations for these samples are discarded automatically, so we don't need to worry about this.

##### Creating the objects we need for the RACD plots #####

## Row 1 consists of RACD maps. So, we will create vectors that contain the posterior mean of the number of activity centres in each pixel
racd.7occ <- no.movement.density.vector(results=results.7occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.25occ <-  no.movement.density.vector(results=results.25occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))
racd.55occ <- no.movement.density.vector(results=results.55occ, M=300, xlim=c(0.5, 50.5), ylim=c(0.5, 50.5))

## ---------------------------------------------------------------------------------------
# Creating the objects we specifically need for the plots in Row 2 of Figure 5
## ---------------------------------------------------------------------------------------

## Row 2 consists of EACD maps. The SCR models that we fit to create these maps assume that the state process (the random process governing the distribution of the activity centres) is an inhomogeneous Poisson process.

##### Covariate value for each pixel #####

# Same as above
log.dblur <- eacd.covariate()

## Loading in the RData files containing the MCMC results 
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_7occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_25occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_55occ.RData")
# Discarding burn-in
inhom.results.7occ <- inhom.results.7occ[-c(1:1000),]
inhom.results.25occ <- inhom.results.25occ[-c(1:1000),]
inhom.results.55occ <- inhom.results.55occ[-c(1:1000),]

##### Creating the objects we need for the EACD plots #####

## Creating vectors containing density values for each pixel when working with 7/25/55 sampling occasions
eacd.7occ <- eacd.density.vector(results=inhom.results.7occ, covariate=log.dblur, nPix=2500)
eacd.25occ <- eacd.density.vector(results=inhom.results.25occ, covariate=log.dblur, nPix=2500)
eacd.55occ <- eacd.density.vector(results=inhom.results.55occ, covariate=log.dblur, nPix=2500)

## ---------------------------------------------------------------------------------------
########################### Objects needed for Figures 4 and 5  ##########################
## ---------------------------------------------------------------------------------------

##### Creating a data frame that contains all of the info required for both figures #####

## Creating a data frame, labelled 'predicted_densities_all', that summarises all of the information that we will use to create the plots included in Figures 4 and 5

## Function to summarise the data for the RACD maps
# The 'nocc' argument is the number of sampling occasions, and 'fig' is the number of the figure for which we wish to summarise data
racd.summary <- function(nocc, fig) {
  # Pixel centres that we are working with
  pixel.centres <- centres(xlim=c(0.5,50.5), ylim=c(0.5,50.5), x.pixels=50, y.pixels=50)
  # Name of array we are working with -- if Figure 4, the name is '3x3' and if Figure 5, the name is '7x7'
  if (fig==4) {
    array <- "3x3"
  } else {
    if (fig==5) {
      array <- "7x7"
    }
  }
  # Obtaining the values for the necessary RACD map
  racd.vals <- get(paste0("racd.", nocc, "occ")) 
  # Data frame of information we want
  dat <- data.frame(x=pixel.centres[,1], y=pixel.centres[,2], covtype=rep("D~1", 2500), occasions=rep(nocc, 2500), array_size=rep(array, 2500), value=racd.vals)
  # Returning this data frame
  dat
}

## Function to summarise the data for the EACD maps -- arguments are the same as the function above
eacd.summary <- function(nocc, fig) {
  pixel.centres <- centres(xlim=c(0.5,50.5), ylim=c(0.5,50.5), x.pixels=50, y.pixels=50)
  if (fig==4) {
    array <- "3x3"
  } else {
    if (fig==5) {
      array <- "7x7"
    }
  }
  eacd.vals <- get(paste0("eacd.", nocc, "occ")) 
  dat <- data.frame(x=pixel.centres[,1], y=pixel.centres[,2], covtype=rep("D~log(Dblur)", 2500), occasions=rep(nocc, 2500), array_size=rep(array, 2500), value=eacd.vals)
  dat
}

## Function to create the final 'predicted_densities_all' object
# Here, 'nocc' is the vector of sampling occasions we are working with; 'fig' is the corresponding figure number for each map; 'type' is the corresponding type of map we want to create (enter as 'RACD' or 'EACD')
overall.summary <- function(nocc, fig, type) {
  # Initialising data frame
  dat <- data.frame()
  for (i in 1:length(nocc)) {
    # If type="RACD", creating a data frame summarising the info for the RACD map corresponding to the given number of sampling occasions and given figure number
    if (type[i]=="RACD") {
      dat.add <- racd.summary(nocc=nocc[i], fig=fig[i])
    } else {
      # If type="EACD", creating a data frame summarising the info for the EACD map
      if (type[i]=="EACD") {
        dat.add <- eacd.summary(nocc=nocc[i], fig=fig[i])
      }
    }
    # Adding the data frame created by racd.summary() or eacd.summary() to our 'dat' data frame
    dat <- rbind(dat, dat.add)
  }
  # Returning the final data frame
  dat
}

## Creating the 'predicted_densities_all' data frame
nocc <- c(rep(c(18, 52, 111), 2), rep(c(7, 25, 55), 2))
fig <- c(rep(4, 6), rep(5, 6))
type <- c(rep(c(rep("RACD", 3), rep("EACD", 3)), 2))
predicted_densities_all <- overall.summary(nocc=nocc, fig=fig, type=type)

##### Object that contains information about the detectors in both figures #####

detectors_df_all <- res_acd %>% purrr::map_depth(1, "detectors_df") %>% map_df(bind_rows)
detectors_df_all <- detectors_df_all %>% distinct()

##### Defining the max value of the colour scale #####

## We want this value to be the same for both Figures 4 and 5.

nn <- 3 # Number of simulated datasets we use in each figure  
xx <- predicted_densities_all %>% filter(array_size == "3x3", occasions %in% capthists_few_alloccs_3x3$noccasions[1:nn])
maxval1 <- max(xx$value) # Max density value found across all plots in Figure 4
xx <- predicted_densities_all %>% filter(array_size == "7x7", occasions %in% capthists_few_alloccs_7x7$noccasions[1:nn])
maxval2 <- max(xx$value) # Max density value found across all plots in Figure 5
maxval <- max(maxval1, maxval2) # Using the higher of these two max values as the top value of the colour scale for plots in both figures

## ---------------------------------------------------------------------------------------
################################### Creating Figure 4 ####################################
## ---------------------------------------------------------------------------------------

##### Adding the column and row labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects #####

nn <- 3 # Number of different simulated datasets used in Figure 4
occ <- capthists_few_alloccs_3x3$noccasions # Number of sampling occasions for each dataset
asz <- c("3x3")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_3x3$capthist, summary, terse = TRUE)))
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist() # Column lables for Figure 4

## Adding the column labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$occasions2 <- factor(predicted_densities_all$occasions, 
                                             levels = occ,
                                             labels = capthist_labels)
detectors_df_all$occasions2 <- factor(detectors_df_all$occasions, 
                                      levels = occ,
                                      labels = capthist_labels)

## Adding the row labels for Figure 4 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$covtype2 <- factor(predicted_densities_all$covtype, 
                                           levels = unique(predicted_densities_all$covtype),
                                           labels = c("Realised AC", "Expected AC"))
detectors_df_all$covtype2 <- factor(detectors_df_all$covtype, 
                                    levels = unique(detectors_df_all$covtype),
                                    labels = c("Realised AC", "Expected AC"))

##### Creating and saving Figure 4 #####

fig4 <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) + 
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

fig4
@

<<fig5, echo = FALSE, include = TRUE, fig.cap = "A version of Figure 5 from the manuscript based on our Bayesian models fitted via MCMC.", message=FALSE, fig.width=10, warning=FALSE, results=hide, fig=TRUE>>=
## ---------------------------------------------------------------------------------------
################################### Creating Figure 5 ####################################
## ---------------------------------------------------------------------------------------

##### Adding the column and row labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects #####

nn <- 3
occ <-capthists_few_alloccs_7x7$noccasions
asz <- c("7x7")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_7x7$capthist, summary, terse = TRUE)))
chs <- chs %>% dplyr::filter(Occasions %in% occ)
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist()

## Adding the column labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$occasions2 <- factor(predicted_densities_all$occasions, 
                                             levels = occ,
                                             labels = capthist_labels)
detectors_df_all$occasions2 <- factor(detectors_df_all$occasions, 
                                      levels = occ,
                                      labels = capthist_labels)

## Adding the row labels for Figure 5 to the 'predicted_densities_all' and 'detectors_df_all' objects
predicted_densities_all$covtype2 <- factor(predicted_densities_all$covtype, 
                                           levels = unique(predicted_densities_all$covtype),
                                           labels = c("Realised AC", "Expected AC"))
detectors_df_all$covtype2 <- factor(detectors_df_all$covtype, 
                                    levels = unique(detectors_df_all$covtype),
                                    labels = c("Realised AC", "Expected AC"))

##### Creating and saving Figure 5 #####

fig5 <- predicted_densities_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) + 
  facet_grid(covtype2 ~ occasions2) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  theme_bw(base_size = 14) +
  coord_equal() +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

fig5
@

\subsection{Uncertainty plots}

<<fig4-uncertainty, echo = FALSE, include = TRUE, fig.cap = "Plots visualising the uncertainty present in the expected activity centre surfaces from Figure 4.", message=FALSE, fig.width=10, warning=FALSE, results=hide, fig=TRUE>>=
## For each EACD plot in Figures 4 and 5, we will create two uncertainty plots: one showing the lower 5% quantile for the posterior distribution of the density for each pixel, the other will show the upper 95% quantile.
## We will create two figures. One will show the uncertainty plots from Figure 4, along with the corresponding EACD plots. The other figure will show the same thing, but for Figure 5. We will refer to these figures as 'uncertainty figures' in the code below. 

## First, we will create the objects needed to create both figures. We will then put together the uncertainty figure for Figure 4 at the end of this chunk. We work like this because we want the same maximum value to be used when colouring both figures.

## ---------------------------------------------------------------------------------------
#################### Objects needed for uncertainty figure for Figure 4 ##################
## ---------------------------------------------------------------------------------------

## Loading in the MCMC results from Row 2 of Figure 4
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_18occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_52occ.RData")
load("../../bayesian_code/MCMC_Results/Figure4/InhomPP_111occ.RData")
# Discarding burn-in
inhom.results.18occ <- inhom.results.18occ[-c(1:1000),]
inhom.results.52occ <- inhom.results.52occ[-c(1:1000),]
inhom.results.111occ <- inhom.results.111occ[-c(1:1000),]

## Covariate that we use for these EACD plots (see 'Functions.R' for an explanation of the function)
log.dblur <- eacd.covariate()

## Creating the data frames that will contain all of the info required to create the uncertainty figure for Figure 4
# 18 sampling occasions
info.18occ <- eacd.quantile.info(results=inhom.results.18occ, covariate=log.dblur, nPix=2500, nocc=18)
# 52 sampling occasions
info.52occ <- eacd.quantile.info(results=inhom.results.52occ, covariate=log.dblur, nPix=2500, nocc=52)
# 111 sampling occasions
info.111occ <- eacd.quantile.info(results=inhom.results.111occ, covariate=log.dblur, nPix=2500, nocc=111)

## ---------------------------------------------------------------------------------------
#################### Objects needed for uncertainty figure for Figure 5 ##################
## ---------------------------------------------------------------------------------------

## Loading in the MCMC results from Row 2 of Figure 5
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_7occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_25occ.RData")
load("../../bayesian_code/MCMC_Results/Figure5/InhomPP_55occ.RData")
# Discarding burn-in
inhom.results.7occ <- inhom.results.7occ[-c(1:1000),]
inhom.results.25occ <- inhom.results.25occ[-c(1:1000),]
inhom.results.55occ <- inhom.results.55occ[-c(1:1000),]

## Covariate we use is the same as above
log.dblur <- eacd.covariate()

## Creating the data frames that will contain all of the info require to create the uncertainty figure for Figure 5
# 7 sampling occasions
info.7occ <- eacd.quantile.info(results=inhom.results.7occ, covariate=log.dblur, nPix=2500, nocc=7)
# 25 sampling occasions
info.25occ <- eacd.quantile.info(results=inhom.results.25occ, covariate=log.dblur, nPix=2500, nocc=25)
# 55 sampling occasions
info.55occ <- eacd.quantile.info(results=inhom.results.55occ, covariate=log.dblur, nPix=2500, nocc=55)

## ---------------------------------------------------------------------------------------
####################### Objects needed for both uncertainty figures ######################
## ---------------------------------------------------------------------------------------

## Collating all information for figures into one data frame
values_all <- rbind(info.18occ, info.52occ, info.111occ, info.7occ, info.25occ, info.55occ)

## Detectors
detectors_df_all <- res_acd %>% purrr::map_depth(1, "detectors_df") %>% map_df(bind_rows)
detectors_df_all <- detectors_df_all %>% distinct()

## Maximum value for colour scale for *all* plots
maxval <- max(values_all$value)

## ---------------------------------------------------------------------------------------
######################## Creating uncertainty figure for Figure 4 ########################
## ---------------------------------------------------------------------------------------

nn <- 3 # Number of different simulated datasets used in Figure 4
occ <- capthists_few_alloccs_3x3$noccasions # Number of sampling occasions for each dataset
asz <- c("3x3")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_3x3$capthist, summary, terse = TRUE)))
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist() # Row labels we'll use

## Adding faceting info to 'values_all' for rows that we will use in this uncertainty figure
values_all$covtype2 <- factor(values_all$covtype, levels=unique(values_all$covtype),
                              labels=c("Expected AC"))
values_all$quantile <- factor(rep(c(rep("0.05 quantile", 2500), rep("Mean", 2500), rep("0.95 quantile", 2500)), 3),
                              levels=c("0.05 quantile", "Mean", "0.95 quantile"))
values_all$occasions2 <- factor(values_all$occasions,
                                levels = occ,
                                labels = capthist_labels)

## Creating and saving the uncertainty figure
uncertainty.fig4 <- values_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) + 
  facet_grid(occasions2 ~ quantile) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

uncertainty.fig4
@ 

<<fig5-uncertainty, echo = FALSE, include = TRUE, fig.cap = "Plots visualising the uncertainty present in the expected activity centre surfaces from Figure 5.", message=FALSE, fig.width=10, warning=FALSE, results=hide, fig=TRUE>>=
## ---------------------------------------------------------------------------------------
######################## Creating uncertainty figure for Figure 5 ########################
## ---------------------------------------------------------------------------------------

nn <- 3
occ <-capthists_few_alloccs_7x7$noccasions
asz <- c("7x7")
chs <- data.frame(do.call(rbind, lapply(capthists_few_alloccs_7x7$capthist, summary, terse = TRUE)))
chs <- chs %>% dplyr::filter(Occasions %in% occ)
paster <- function(nd,na){
  paste0(nd," detections\n(",na, " individuals)")
}
capthist_labels <- map2(.x = chs$Detections, .y = chs$Animals, .f = paster) %>% unlist()

## Adding faceting info for rows that we will use to create this uncertainty figure  
values_all$occasions2 <- factor(values_all$occasions,
                                levels = occ,
                                labels = capthist_labels)

## Creating and saving the uncertainty figure
uncertainty.fig5 <- values_all %>%
  filter(occasions %in% occ[1:nn], array_size %in% asz) %>%
  ggplot(aes(x, y)) + 
  geom_raster(aes(fill = value)) +
  scale_fill_distiller(limits=c(0, maxval)) + 
  facet_grid(occasions2 ~ quantile) +
  geom_point(data = detectors_df_all %>% filter(occasions %in% occ[1:nn], array_size %in% asz), inherit.aes = T,
             colour = "gray80", pch = 4, size = 2) +
  geom_point(data = simulated_points, inherit.aes = F, aes(x=x,y=y),
             colour = "darkorange", pch = 16, size = 1, alpha = 0.5) +
  coord_equal() +
  theme_classic(base_size = 14) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.spacing=unit(-1, "lines"),
        strip.background = element_rect(fill=NA, colour = NA), 
        legend.position="right", legend.key.width = unit(0.5, "cm"),
        legend.key.height = unit(1.3,"cm"), legend.title = element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank())

uncertainty.fig5
@ 


\section{Realised usage density}

Estimation of realised usage density is a similar process for both
maximum likelihood and Bayesian approaches: we sum usage densities for
each individual animal, each of which is calculated by convolving the
posterior probability density function of its activity centre with an
individual usage distribution.

\subsection{The maximum likelihood approach}

For maximum likelihood, the estimated usage density for the $i$th
animal, with capture history $\bm{\omega}_i$, is given by
\begin{equation}
f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid \bm{\omega}_i; \bm{\widehat{\theta}}) =
\int f_{\bm{x} \mid \bm{\omega}}(\bm{x} \mid \bm{\omega}_i; \bm{\widehat{\theta}})
f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \bm{\widehat{\theta}}) d\bm{x}, \label{eq:ind-usage}
\end{equation}
where
\begin{itemize}
\item $\bm{\widehat{\theta}}$ is a vector containing the maximum
  likelihood estimates of the encounter function parameters;
\item $f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid
  \bm{\omega}_i; \bm{\widehat{\theta}})$ is the estimated usage distribution, providing the
  probability density of finding an individual with capture history
  $\bm{\omega}_i$ at location $\bm{s}$ at a randomly selected point in
  time;
\item $f_{\bm{x} \mid \bm{\omega}}(\bm{x} \mid \bm{\omega}_i;
  \bm{\widehat{\theta}})$ is the estimated PDF of the activity centre
  of an individual with capture history $\bm{\omega}_i$ (see Section
  3); and
\item $f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \bm{\widehat{\theta}})$ is the
  estimated usage distribution of the individual conditional on the
  activity centre, providing the probability density of the individual
  being at location $\bm{s}$ given that its activity centre is at
  $\bm{x}$.
\end{itemize}
Estimated usage density at location $\bm{s}$ is then given by
$\widehat{D}_u(\bm{s}) = \sum_i f_{\bm{s} \mid
  \bm{\omega}}(\bm{s} \mid \bm{\omega}_i; \bm{\widehat{\theta}})$, noting that the sum is
over individuals that were not detected, with capture histories $(0,
\cdots, 0)$, along with those that were.

Here we constructed the individual usage distribution under the
assumption that the density of an individual being at location
$\bm{s}$ given its activity centre is at $\bm{x}$ is proportional to
the encounter function $h\{d(\bm{s}, \bm{x});
\widehat{\bm{\theta}}\}$, where $d(\bm{s}, \bm{x})$ is the Euclidean
distance between $\bm{s}$ and $\bm{x}$, and so
\begin{equation}
  f_{\bm{s} \mid \bm{x}}(\bm{s} \mid \bm{x}; \widehat{\bm{\theta}}) = \frac{h\{d(\bm{s}, \bm{x}); \widehat{\bm{\theta}}\}}{\int h\{d(\bm{s}^\prime, \bm{x}); \widehat{\bm{\theta}}\} d\bm{s}^\prime},
\end{equation}
where the denominator is a normalising constant.

\subsection{The Bayesian approach}

Bayesian models fitted via MCMC can directly sample activity centres
of detected individuals, and also of undetected individuals using data
augmentation, thus obtaining samples from $f_{\bm{x} \mid
  \bm{\omega}}(\bm{x} \mid \bm{\omega})$ for each individual. We can
use these samples directly to obtain the following approximation of
the $i$th individual's usage distribution:
\begin{equation}
  f_{\bm{s} \mid \bm{\omega}}(\bm{s} \mid \bm{\omega}_i) \approx
  \frac{1}{J} \sum_{j = 1}^J f_{\bm{s} \mid \bm{x}}(\bm{s} \mid
  \bm{x}_{(j)}, \bm{\theta}_{(j)}),
\end{equation}
where $\bm{x}_{(j)}$ and $\bm{{\theta}}_{(j)}$ are the activity centre
and a vector of encounter function parameters that were sampled on the
$j$th of $J$ total MCMC iterations, respectively. The estimated usage
distribution is therefore not conditional on one particular set of
estimated parameter values, but instead considers the range of values
across the posterior distribution of $\bm{\theta}$.

% \subsection{Discussion}
% 
% \todo[inline]{I'm not sure that this is the best place for the
%   discussion below, but leaving it here for now.}
% 
% We constructed individual usage distributions using the encounter
% function from our SCR model, but this may not always be
% appropriate. For example, if individuals cannot fully explore their
% home range within the duration of the survey, then we would not expect
% the spatial range of the detection function to match the extent of an
% animal's usage distribution.
% 
% Even for longer surveys, it may not be sensible to relate the range of
% the encounter function to the size of the region used by an individual
% even for longer surveys, so care should be taken when this practice is
% used. For example, \citet{Tenan+al:17} found that the spatial scale of
% the encounter rate function for brown bears (\emph{Ursus arctos})
% estimated using SCR was not consistent with spatial usage parameters
% estimated from other data sources, although \citet{Popescu+al:14} did
% not detect any such inconsistency for a population of fishers
% (\emph{Pekania pennanti}). If alternative data sources are available
% (e.g., telemetry, or opportunistic data such as hair or scat samples)
% they may be incoprorated for improved estimation of individual usage
% distributions \citep{Tenan+al:17}.
% 
% Our method also assumes that home ranges are circular, however their
% shapes are likely to be modified by variables relating to population
% and landscape connectivity \citep[see][for a review]{Drake+al:ip}.


\bibliographystyle{../mee} \bibliography{../monalisa}

\end{document}
