## Creating ch7e RData object using function

## First, sourcing in capture history matrix we need
#load("../output/capthists.RData")
load("capthists.RData") # for NeSI

## ch7e
ch7e = capthists_expected_acd_many$capthist[1][[1]]
encounterdat.ch7e = matrix(0, nrow=nrow(ch7e[,1,]), ncol=ncol(ch7e[,1,]))
for (i in 1:20) {
  encounterdat.ch7e = encounterdat.ch7e + ch7e[,i,]
}
ch7e.traploc = attributes(ch7e)$traps
data.ch7e = list(encounter.data = encounterdat.ch7e, trap.loc = ch7e.traploc)

## ---------------------------------------------------------------------------------------

# Running the MCMC

## ---------------------------------------------------------------------------------------

# Libraries we need
library(nimble)
library(coda)
library(nimbleSCR)

# Sourcing in the function that we'll need to run the MCMC
source("MCMC_Function_Inhomogeneous.R")
library("spatstat")

## Generating the value of our chosen covariate for each pixel (as we are assuming an inhomgeneous Poisson process)
# First, need to load 'mona_df' -- this contains the covariate values that we want to use
#load("../output/mona_inputs.RData")
load("mona_inputs.RData") # For NeSI
# We want to subset the 'Dgood' column from the resulting data frame, as this contains the values for our chosen covariate here. We also are subsetting
# the x- and y-coordinate columns (these give the pixel centres that correspond to each covariate value)
mona.densities = mona_df[,c("x", "y", "Dblur_bigD")]
# Lastly, we want to reorder our 'mona.densities' data frame, so that the order of the pixels in the data frame matches the order of the pixels in our 'pixel.centres' object (generated by the centres() function). Currently, both objects have the pixels in the 'opposite' order to each other -- making the order of the pixels the same in both objects means that it'll be easier to write our NIMBLE model (as both objects can be subsetted using the same indices). To do this reordering, we need to reverse the order of the 'y' column only - so we split up data frame into groups based on the y-values, and then re-join the result into a data frame where the smallest y-values occur in the first rows and the largest ones are in the last rows of the data frame. We do this below.
split = split(mona.densities, mona.densities$y)
mona.densities = do.call("rbind", split)
# And now that we are sure of the way in which the pixels are numbered, can remove the x and y-coordinate columns, so that we are now left with a density vector only, which we will then use with NIMBLE!
dblur = mona.densities[,"Dblur_bigD"]

## Generating 'pixel.info' object we need
# Pixel centres in the map region
# Function
centres = function(xrange, yrange, x.pixels, y.pixels) {
  window.2 = owin(xrange=xrange, yrange=yrange)
  points = gridcentres(window.2, x.pixels, y.pixels)
  centres = as.matrix(cbind(points$x, points$y))
  centres
}
pixel.centres = centres(xrange=c(0.5, 50.5), yrange=c(0.5, 50.5), x.pixels=50, y.pixels=50)
pixel.info = cbind(pixel.centres, dblur)

ch7e.sample = run.MCMC.inhom(data.ch7e, pixel.info=pixel.info, x.pixels=50, y.pixels=50, M=9000, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
save(ch7e.sample, file="ch7e.RData")
