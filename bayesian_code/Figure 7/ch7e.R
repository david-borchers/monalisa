## Creating RData object to run the MCMC object for plot (e) in Figure 7
# First, sourcing in capture history matrix we need
load("../../output/capthists.RData")
# Encounter matrix
ch7e = capthists_expected_acd_many$capthist[1][[1]]
encounterdat.ch7e = matrix(0, nrow=nrow(ch7e[,1,]), ncol=ncol(ch7e[,1,]))
for (i in 1:20) {
  encounterdat.ch7e = encounterdat.ch7e + ch7e[,i,]
}
# Trap locations
ch7e.traploc = attributes(ch7e)$traps
# Data object
data.ch7e = list(encounter.data = encounterdat.ch7e, trap.loc = ch7e.traploc)

## ---------------------------------------------------------------------------------------

# Running the MCMC

## ---------------------------------------------------------------------------------------

# Libraries we need
library(nimble)
library(coda)
library(nimbleSCR)
library(spatstat)

# Sourcing in the function that we'll need to run the MCMC
source("../MCMC_Function_Inhomogeneous.R")

## Generating the value of our chosen covariate for each pixel (as we are assuming an inhomgeneous Poisson process)
# First, need to load 'mona_df' -- this contains the covariate values that we want to use
load("../../output/mona_inputs.RData")
# We want to subset the 'Dblur_bigD' column from the resulting data frame, as this contains the values for our chosen covariate here. We also are subsetting the x- and y-coordinate columns (these give the pixel centres that correspond to each covariate value)
mona.densities = mona_df[,c("x", "y", "Dblur_bigD")]
# Lastly, we want to reorder our 'mona.densities' data frame, so that the order of the pixels in the data frame matches the order of the pixels in our 'pixel.centres' object (generated by the centres() function)
split = split(mona.densities, mona.densities$y)
mona.densities = do.call("rbind", split)
# And now that we are sure of the way in which the pixels are numbered, can remove the x and y-coordinate columns, so that we are now left with a density vector only, which we will then use with NIMBLE
dblur = mona.densities[,"Dblur_bigD"]
# Logging the covariate
dblur = log(dblur)

## Generating 'pixel.info' object we need to run our MCMC (see function description in 'MCMC_Function_Inhomogeneous.R' for more info on this object)
# Pixel centres in the map region
source("../RUDMaps_Functions.R")
pixel.centres = centres(xrange=c(0.5, 50.5), yrange=c(0.5, 50.5), x.pixels=50, y.pixels=50)
pixel.info = cbind(pixel.centres, dblur)

## Fitting the model, saving the results
ch7e.sample = run.MCMC.inhom(data.ch7e, pixel.info=pixel.info, x.pixels=50, y.pixels=50, M=9000, inits.vec=c(10, 4, 0), n.iter=100000, n.burn=1000)
save(ch7e.sample, file="ch7e.RData")
